package chiseltest.legacy.backends.verilator

import firrtl.FileUtils

import java.io.{File, FileWriter}
import java.nio.file.{Files, Path, Paths}

/** Changes the file generated by verilator to generate per instance and not per module coverage.
  * This is required in order to satisfy our generic TestCoverage interface for which
  * the simulator needs to return per instance coverage counts.
  * See: https://github.com/verilator/verilator/issues/2793
  */
object PatchCoverageCpp {
  private val Needle1 = """VL_COVER_INSERT(count32p,  "filename",filenamep,  "lineno",lineno,  "column",column,"""
  private val Needle2 = """"hier",std::string(name())+hierp,  "page",pagep,  """
  // We replace the comment (which seems to always be "cover") with the
  // "per_instance" settings. Just adding the "per_instance" key in the end
  // somehow did not work.
  private val OldSuffix = """"comment",commentp);"""
  private val NewSuffix = """"per_instance", "1");"""

  def apply(dir: String, main: String): Unit = {
    val cppFile = Paths.get(dir, s"V$main.cpp")
    val lines = loadFile(cppFile)
    replaceCoverage(cppFile, lines)
    doWrite(cppFile, lines)
  }

  private def replaceCoverage(cppFile: Path, lines: Array[String]): Unit = {
    val line1 = lines
      .map(_.trim)
      .zipWithIndex
      .find(_._1.startsWith(Needle1))
      .getOrElse {
        error(s"Failed to find line `$Needle1` in $cppFile.")
      }
      ._2
    val line2 = line1 + 1
    if (!lines(line2).trim.endsWith(Needle2 + OldSuffix)) {
      error(s"Failed to find line `$Needle2$OldSuffix` in $cppFile.")
    }

    // we essentially just append the new Suffix which will turn per instance coverage on
    val newLine = lines(line2).dropRight(OldSuffix.length) + NewSuffix
    lines(line2) = newLine
  }

  private def loadFile(cppFile: Path): Array[String] = {
    // check to make sure that we can find the verilator generated cpp file
    if (!Files.exists(cppFile)) {
      error(s"Failed to find $cppFile")
    }
    FileUtils.getLines(cppFile.toFile).toArray
  }

  private def doWrite(file: Path, lines: Array[String]): Unit = {
    val writer = new FileWriter(file.toFile)
    writer.write(lines.mkString("\n"))
    writer.close()
  }

  private def error(msg: String): Nothing = {
    throw new RuntimeException(msg + "\n" + "Please file an issue and include the output of `verilator --version`")
  }
}
