// See LICENSE for license details.
package chiseltest.backends

import chisel3.experimental.{DataMirror, FixedPoint, Interval}
import chisel3.internal.firrtl.KnownWidth
import chisel3.{SInt, _}
import chiseltest.backends.VPIInterface
import chiseltest.internal.ThreadedBackend
import firrtl.AnnotationSeq
import logger.LazyLogging
import treadle.utils.BitMasks

import scala.math.BigInt

/** Supports Backend and Threaded traits for ex
  *
  * @param annos annotations generated by firrtl.
  * @tparam T the dut's type
  */
class VPIBackend[T <: MultiIOModule](val annos: AnnotationSeq)
  extends ThreadedBackend[T]
    with LazyLogging {

  val simulatorInterface: SimulatorInterface = new VPIInterface(annos)

  /** Since VPI don't know what datatype is, it should be resolved. */
  override def peekBits(signal: Data, stale: Boolean): BigInt = {
    val superResult = super.peekBits(signal, stale)

    def unsignedBigIntToSigned(unsigned: BigInt, width: Int): BigInt = {
      val bitMasks = BitMasks.getBitMasksBigs(width)
      if (unsigned < 0) {
        unsigned
      } else {
        if (bitMasks.isMsbSet(unsigned)) {
          (unsigned & bitMasks.allBitsMask) - bitMasks.nextPowerOfTwo
        } else {
          unsigned & bitMasks.allBitsMask
        }
      }
    }

    /** @todo don't use [[DataMirror]] anymore.
      *       consume information from firrtl. */
    signal match {
      case s: SInt =>
        val width = DataMirror.widthOf(s).asInstanceOf[KnownWidth].value
        unsignedBigIntToSigned(superResult, width)
      case f: FixedPoint =>
        val width = DataMirror.widthOf(f).asInstanceOf[KnownWidth].value
        unsignedBigIntToSigned(superResult, width)
      case i: Interval =>
        val width = DataMirror.widthOf(i).asInstanceOf[KnownWidth].value
        unsignedBigIntToSigned(superResult, width)
      case _ => superResult
    }
  }
}
