// See LICENSE for license details.
package chiseltest.backends

import chisel3.experimental.{DataMirror, FixedPoint, Interval}
import chisel3.internal.firrtl.KnownWidth
import chisel3.{SInt, _}
import chiseltest.backends.verilator.SimApiInterface
import chiseltest.internal.{FailedExpectException, ThreadedBackend}
import chiseltest.{Region, TimeoutException}
import firrtl.AnnotationSeq
import logger.LazyLogging
import treadle.utils.BitMasks

import scala.collection.mutable
import scala.math.BigInt

/** Supports Backend and Threaded traits for ex
  *
  * @param annos annotations generated by firrtl.
  * @tparam T the dut's type
  */
// TODO: is Seq[CombinationalPath] the right API here? It's unclear where name -> Data resolution should go
class VerilatorBackend[T <: MultiIOModule](val annos: AnnotationSeq) extends ThreadedBackend[T]
  with LazyLogging {

  private[chiseltest] val simApiInterface = new SimApiInterface(circuit, command)

  protected def resolveName(signal: Data): String = { // TODO: unify w/ dataNames?
    dataNames.getOrElse(signal, signal.toString)
  }

  //
  // Everything else
  //

  def getModule: T = dut

  override def pokeClock(signal: Clock, value: Boolean): Unit = {
    // TODO: check thread ordering

    val intValue = if (value) 1 else 0
    simApiInterface.poke(dataNames(signal), intValue)
    logger debug (s"${resolveName(signal)} <- $intValue")
  }

  override def peekClock(signal: Clock): Boolean = {
    doPeek(signal, new Throwable)
    val a = simApiInterface.peek(dataNames(signal)).getOrElse(BigInt(0))
    logger debug (s"${resolveName(signal)} -> $a")
    a > 0
  }

  override def pokeBits(signal: Data, value: BigInt): Unit = {
    doPoke(signal, value, new Throwable)
    val dataName = dataNames(signal)
    simApiInterface.peek(dataName) match {
      case Some(peekValue) =>
        if (peekValue != value) {
          idleCycles.clear()
        }
        simApiInterface.poke(dataNames(signal), value)
        logger debug (s"${resolveName(signal)} <- $value")
      case None =>
        logger debug (s"${resolveName(signal)} is eliminated by firrtl, ignore it. ")
    }
  }

  override def peekBits(signal: Data, stale: Boolean): BigInt = {
    require(!stale, "Stale peek not yet implemented")

    doPeek(signal, new Throwable)
    val dataName = dataNames(signal)
    val a = simApiInterface.peek(dataName) match {
      case Some(peekValue) => {
        logger debug (s"${resolveName(signal)} -> $peekValue")
        peekValue
      }
      case None => {
        logger debug (s"${resolveName(signal)} is eliminated by firrtl, default 0.")
        BigInt(0)
      }
    }

    def unsignedBigIntToSigned(unsigned: BigInt, width: Int): BigInt = {
      val bitMasks = BitMasks.getBitMasksBigs(width)
      if (unsigned < 0) {
        unsigned
      } else {
        if (bitMasks.isMsbSet(unsigned)) {
          (unsigned & bitMasks.allBitsMask) - bitMasks.nextPowerOfTwo
        } else {
          unsigned & bitMasks.allBitsMask
        }
      }
    }

    signal match {
      case s: SInt =>
        val width = DataMirror.widthOf(s).asInstanceOf[KnownWidth].value
        unsignedBigIntToSigned(a, width)
      case f: FixedPoint =>
        val width = DataMirror.widthOf(f).asInstanceOf[KnownWidth].value
        unsignedBigIntToSigned(a, width)
      case i: Interval =>
        val width = DataMirror.widthOf(i).asInstanceOf[KnownWidth].value
        unsignedBigIntToSigned(a, width)
      case _ => a
    }
  }

  override def expectBits(signal: Data,
                          value: BigInt,
                          message: Option[String],
                          // @todo rebase wip.
                          decode: Option[BigInt => String],
                          stale: Boolean): Unit = {
    require(!stale, "Stale peek not yet implemented")
    logger debug (s"${resolveName(signal)} ?> $value")
    val actual = peekBits(signal, stale)
    if (value != actual) {
      val appendMsg = message match {
        case Some(_) => s": $message"
        case _ => ""
      }

      val trace = new Throwable
      val expectStackDepth = trace.getStackTrace.indexWhere(ste =>
        ste.getClassName == "chiseltest.package$testableData" && ste.getMethodName == "expect")
      require(expectStackDepth != -1, s"Failed to find expect in stack trace:\r\n${trace.getStackTrace.mkString("\r\n")}")
      val message1 = s"$signal=$actual did not equal expected=$value$appendMsg"
      val stackIndex = expectStackDepth + 1
      throw new FailedExpectException(message1, stackIndex)
    }
  }

  protected val clockCounter: mutable.HashMap[Clock, Int] = mutable.HashMap()

  protected def getClockCycle(clk: Clock): Int = {
    clockCounter.getOrElse(clk, 0)
  }

  protected def getClock(clk: Clock): Boolean =
    simApiInterface.peek(dataNames(clk)) match {
      case Some(x) if x == BigInt(1) => true
      case _ => false
    }

  protected val lastClockValue: mutable.HashMap[Clock, Boolean] =
    mutable.HashMap()

  override def doTimescope(contents: () => Unit): Unit = {
    val createdTimescope = newTimescope()

    contents()

    closeTimescope(createdTimescope).foreach {
      case (data, valueOption) =>
        valueOption match {
          case Some(value) =>
            if (simApiInterface.peek(dataNames(data)).get != value) {
              idleCycles.clear()
            }
            simApiInterface.poke(dataNames(data), value)
            logger debug (s"${resolveName(data)} <- (revert) $value")
          case None =>
            idleCycles.clear()
            simApiInterface.poke(dataNames(data), 0) // TODO: randomize or 4-state sim
            logger debug (s"${resolveName(data)} <- (revert) DC")
        }
    }
  }

  override def step(signal: Clock, cycles: Int): Unit = {
    // TODO: maybe a fast condition for when threading is not in use?
    for (_ <- 0 until cycles) {
      // If a new clock, record the current value so change detection is instantaneous
      if (signal != dut.clock && !lastClockValue.contains(signal)) {
        lastClockValue.put(signal, getClock(signal))
      }

      val thisThread = currentThread.get
      thisThread.clockedOn = Some(signal)
      schedulerState.currentThreadIndex += 1
      scheduler()
      thisThread.waiting.acquire()
    }
  }

  override def run(testFn: T => Unit): Unit = {
    rootTimescope = Some(new RootTimescope)
    val mainThread = new TesterThread(
      () => {
        simApiInterface.poke("reset", 1)
        simApiInterface.step(1)
        simApiInterface.poke("reset", 0)

        testFn(dut)
      },
      TimeRegion(0, Region.default),
      rootTimescope.get,
      0,
      Region.default,
      None
    )
    mainThread.thread.start()
    require(allThreads.isEmpty)
    allThreads += mainThread

    try {
      while (!mainThread.done) { // iterate timesteps
        clockCounter.put(dut.clock, getClockCycle(dut.clock) + 1)

        logger debug (s"clock step")

        // TODO: allow dependent clocks to step based on test stimulus generator
        // TODO: remove multiple invocations of getClock
        // Unblock threads waiting on dependent clock
        val steppedClocks = Seq(dut.clock) ++ lastClockValue.collect {
          case (clock, lastValue)
            if getClock(clock) != lastValue && getClock(clock) =>
            clock
        }
        steppedClocks foreach { clock =>
          clockCounter.put(dut.clock, getClockCycle(clock) + 1) // TODO: ignores cycles before a clock was stepped on
        }
        lastClockValue foreach {
          case (clock, _) =>
            lastClockValue.put(clock, getClock(clock))
        }

        runThreads(steppedClocks.toSet)

        idleLimits foreach {
          case (clock, limit) =>
            idleCycles.put(clock, idleCycles.getOrElse(clock, -1) + 1)
            if (idleCycles(clock) >= limit) {
              throw new TimeoutException(
                s"timeout on $clock at $limit idle cycles"
              )
            }
        }

        simApiInterface.step(1)
      }
    } finally {
      rootTimescope = None

      for (thread <- allThreads.clone()) {
        // Kill the threads using an InterruptedException
        if (thread.thread.isAlive) {
          thread.thread.interrupt()
        }
      }

      simApiInterface.finish() // Do this to close down the communication
    }
  }

}
